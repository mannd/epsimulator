#+TITLE: EP Simulator Development Notes
* Style
** Style guides
*** Google C++ Style Guide
    http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml#The__define_Guard
*** C++ Programming Style Guidelines
    http://geosoft.no/development/cppstyle.html
** Specifics
*** Header files
**** Include guards
***** EP_FILENAME_H
      Note all uppercase, and use of EP_ prefix to insure uniqueness.
*** Namespaces
**** Indentation
     Because everything is wrapped in a namespace, indenting namespace
     contents really wastes space.  Exception might be forwardly declared
     classes in namespaces, but perhaps this should also be disallowed.  In
     order to disambiguate the 2 right braces at the end of a namespace,
     adding the namespace name in a comment after the closing brace is important.
**** Names
     Namespace names are capitalized, CamelCase, and begin with Ep.  Thus,
     EpHardware, EpNavigator, EpCore.  The base name is derived from the most
     important class, or function of the namespace.  Namespaces can and should
     span files and even library boundaries.
* Prucka window management implementation
** Major behavior to emulate
   - outer borders of the central widget are not moveable.
   - windows can't be moved inside central window by dragging title
     bar.
   - Resizing windows acts like a splitter bar.
** Other behavior
   - Log window always expands to full width of central widget
   - Odd window location selection behavior
     - when new window is selected in menu, horizontal or vertical
       line is shown on screen, left mouse click opens window in
       quadrant selected.
   - Closing window expands other horizontally aligned windows
   - Uncertain if can open Review2 without Review1 and vice versa
   - Can't close Real-time
     - but no Realtime if review study or no acquisition
       - no acquisition case is handled by Navigator
       - if acquisition changed during study, no effect
	 - maybe should disable that option during study???
** UI implementation of behavior
   Simplest way to implement is via menu options.  Examples:
   - Disable Review2 if no 
* Simplified window management
** rationale
   - Prucka behavior is very MS Windows dependent and would require
     using platform-specific QT window handling code to implement.
     Workarounds trapping mouse events, etc. are very difficult to do.
   - Implementation of Prucka behavior is very difficult, perhaps
     impossible, certainly slowing program development.
   - Prucka-like screen layouts can be manually simulated using an MDI
     setup and then can be saved for reuse.
   - Prucka window management is not standard windows GUI behavior and
     does not fulfil the standard of "least surprise."
** Arguments for Prucka behavior
   - Non-Prucka behavior weakens the simulation verisimilitude.  Why
     include all the other awkward Prucka elements and not this one?
   - Opening new windows such as Review2 requires manually laying out
     of the windows.  Methods to open and rearrange the windows in a
     default way could obviate this.  Saved window layouts could be
     used instead of just opening and closing windows.
   - Specific window behavior is still awkward.  Should the Realtime
     window be closeable?  It isn't in the Prucka.  Can you have a
     Review 2 and not a Review 1?  Not sure about that.  
** Recommendations
   - Recorder subwindows are MDI subwindows, thus use an MDI layout model.
   - In addition to Tile and Cascade, have an Organize Windows menu
     option that lays out the windows Prucka style.  When a new window
     is opened, have option to use the Organize Windows function or
     not.  (AutoOrganizeWindows option?)
   - Windows layouts are saved in study configurations, and when new
     study is loaded, the default study configuration window layout
     will be used.
* Multihead displays
** TwoReviewWindow option
   The basic option is using one or two review windows.  The number of
   physical screens is not important.  Multihead systems act like one
   big screen, thus saving the 2 screens, one on each screen, just
   saves the coordinates and should just work.  Maximizing on 2
   screens may not work right, will need to experiments with a 2
   screen system to be sure.  
** Recorder window layout versus subwindow layout
   Recorder window positions are stored in the EPSimulator.conf file.
   Subwindow layouts are stored in the config.dat files.  The
   rationale is that the user will keep his his Navigator and Recorder
   windows maximized or not, and won't want them changing sizes each
   time a new study is loaded.  The relative positioning of the
   windows will change from study to study.  Downside of this is that
   changing main window size will mess up subwindow locations.
** TODO 
   recorder window currently does store subwindow locations in
   EPSimulator.conf.  This is only the last configuration when the
   window is closed.  Need to work on study configuration data.
** Single document format as key to multiple displays
*** Multiple recorder windows
    The original Recorder window can spawn a new window with a default
    layout.  The new window is a child of the original, so will die when the
    original is killed (I think).  
*** New Window menu item and action
    Essentially this slot will do this:
    Recorder* newRecorder = new Recorder(this, ...);
    This "secondary window" (and there can be more) needs:
      - to have acquisition disabled (can't have 2 real time windows)
      - to leave the primary window there if closed
      - to close automatically when the primary window is closed
*** WindowSetting
    WindowSettings are saved for each Recorder window, as well as the layout
    of the subwindows in each Recorder window.  It would seem WindowSettings
    should be machine-specific, but I am not sure this is the case.
* Qt-creator issues
** gdb problem
   Solution: downloaded later version of gdb from here:
   ftp://ftp.qt.nokia.com/misc/gdb/
* Study vs Patient
** Study contains the initial state of the study
   This includes study specific items, such as date, study number,
   study state, etc.  When a study starts, there is also a patient who
   has an initial state.  This includes unchangeables like sex and
   date of birth but also things that can change from study to study
   like disease state, and also initial vital signs, rhythm, etc.  All
   this is present during each study.
** Different study situations
*** Pre-registered patient, from scratch
    
*** New Patient, from scratch
    User fills in patient demographics, selects patient template
    (defaults to '<default>').  

* Screen size
  Need to convert pixel distances to time intervals.  Screen
  resolution in pixels is known to program, can get from QDesktop
  class.  Sweep speed is set by program, in mm/sec, eg. 100 mm/sec.
  We need to know pixels/mm.  This depends on screen size.  Prucka
  must set this manually, based on monitor sizes.  Wrong screen size
  will make the sweep timing and interval measurements wrong, but not
  grossly so.  Could set default horizontal screen size to 17", but
  have it user modifiable.  Need either measurement or dpi for screen.
  
* Library dependency problems
** Windows settings problem
   git versions up to breaking point:
   edb0e3cbcac33fd872ac5bf7ba88ba4484ac2405
   9bfb5d3f3c97ac802e8887c6958b384b14fde7f2
   7cda2eaa79a4a77d7f1963d9ec2417938ec9ff62

   Last functioning git version is 9bfb5d3f3c....

   Problem is Study contains StudyConfiguration.  StudyConfiguration
   contains lots of data relating to Recorder: channels, amplifier,
   Window settings, etc.  Study just needs to have a
   StudyConfiguration name to start out with.  Recorder needs to
   contain the StudyConfiguration; Navigator also uses it, but
   Navigator references Recorder so that is ok.  Study itself can't
   reference a StudyConfiguration based in Recorder, because Recorder
   has to reference Study, thus circular references....
** Solution
   Eliminate Study library, incorporate it into Recorder library.
* Hardware simulation
** Top-down view
*** Gui
    Sets up the various windows, loads study, etc.
*** RealTimeWindow
**** Arranges channels
**** Runs main program loop (in separate thread?)
*** Main Loop
**** Each timer event
***** for each Channel
****** get voltage
****** store data in database
****** if page visible
******* gain/clip voltage, convert to Y axis distance from 0 voltage
******* draw line segment from last point to current point
*** Channel
    Each amplifier channel is polled.  Channel is either at zero line
    or is depolarizing.  Depolarization starts with the far field
    activation, depending on interelectrode distance.  Voltage is
    copied from an EGM template, chosen randomly for each catheter,
    but constant unless catheter moves.  
*** Catheter
    The catheter is located in the heart.  There are only 2 functional
    chambers: A and V, with special case location bundle of His (has
    A, V and H).  At time of polling, simulation must determine if
    tissue if at zero voltage or being depolarized.  Depolarization is
    a window, the width of the EGM.  During depolarization, an EGM
    template is copied to determine point to point voltage, otherwise
    voltage is zero.  
*** Digression on data format
    Time is a long integer representing milliseconds.  Channel is a
    number corresponding the amplifier channel.  Voltage is the
    channel voltage.  Gap between samples is sampling rate.  Assume
    sampling rate is 60 Hz:

    Time:Channel:Voltage
    0:1:0
    0:2:0
    0:3:.3
    .
    .
    .
    1420:5:3.3
    etc.
    Or, better still:
    Time:Channel:Voltage:Channel:Voltage...etc.
    0:1:0:2:0:3:0.3....etc.
*** Possible way to generate simulation:
    Have a data buffer, and have the simulation generate all the above
    data very quickly.  Probably need to double buffer this.  This can
    be in separate thread.  If Save is on, save the data to disk too.
    Simulation then just looks up time and reads each channel.  Better
    format for this would be binary, with a structure for each time.

    struct ChannelVoltage {
       int channel;
       double voltage;
};

struct Moment {
       long int time;
       ChannelVoltage channels[n];
};

Moment moments[buffersize];

Calculate offset in buffer: actual time mod buffer_size and read that Moment from the buffer, using pointer arithmatic.
* Disk Cache
** The 3 catalogs and data storage - reconsidered
   From reviewing the cardiolink pdf manual, it appears that there are
   several scenarios.
   - Standalone system
   - Networked system
   In both kinds of systems, there are 2 types of data to be
   considered:
   - Catalog data
   - Study data
   Finally, data handling also depends on the acquisition mode.  There
   are really just 2 situations:
   - Acquisition mode
   - Client mode
   If there are multiple EP labs, there are multiple sets of computers
   for acquisition and other functions.  For any one study, there is
   one acquisition computer and possibly multiple client computers, in
   the procedure room, or in the holding are.  These are linked by a
   fast ethernet switch.  The manual implies other computers can be
   linked in for review, such a in the MD's office, via slower
   connections.  As far as I can determine, these are also client
   computers -- I'm not sure if there is a way to limit to just review mode.
** Catalog data
*** Reading catalog data
    Catalog data is always read from the specific catalog selected in
    the Catalog Combobox.  The data file is always "catalog.dat" and
    is a top level file in the optical disk, the System directory on
    the acquisition system, and the network path.  
*** Writing catalog data
**** Networked system
     The network catalog must be highlighted, otherwise everthing is
     written to the local system.  Assuming the network catalog is
     highlighted, then entries go into that specific catalog.  
** Study data
*** Location
    Study data is located in the top-level "studies" directory.  Each
    study is in a subdirectory of the form
    "study_lastname_firstname_studykey."  Within each such directory
    are data files, include "study.dat," "patient.dat," "config.dat,"
    etc.  
*** Writing study data
** System data
   Note that "the windows settings are unique to each acquisition
   system and review workstation."
** OpticalDisk
*** Expanding OpticalDisk
    The OpticalDisk class is initialized by a path.  This is either a
    path to a true optical media drive or a regular directory.  The
    system can detect if this is a true optical drive or not.  A true
    optical drive must use disk caching.  A regular directory or an
    emulated optical drive can either use disk caching or not.  With
    disk caching, a temporary directory is used to read and write
    data.  Data is then "burned" or just copied to the actual optical
    drive.  OpticalDisk handles all this internally.
*** System Catalog
    The System catalog is separate from the Optical catalog.  The
    System catalog tracks which optical disk has which studies.  It is
    supplanted by the Network catalog in a networked system.  If study
    data is kept on network than the system catalog entry for that
    study is deleted after the data is copied/archived to the
    network.  The optical disk though is a permanent copy of the
    study.  A study can be reviewed from the network catalog, but you
    cannot continue a study without the optical disk.
*** Preregister studies
    These studies only appear in the System and Network catalogs.
    They disappear when a study is started or continued.  No
    preregistered study data is written to the optical disk.
*** Optical Catalog
**** Burning times
     When a study is started or continued from Navigator, the catalog
     database is burned to the drive.  When the Recorder windows is
     closed, the catalog is updated if necessary and burned to the
     CD.  Data is burned to the CD after being written to the cache,
     in chunks, in a separate thread.  When the study is closed, any
     unburned data is burned.
**** Burning
     If no disk cache is used then all writing is directly to the
     "optical disk" directory, and burning is a no-op.  The disk cache
     is the directory.
*** Disk Cache reconsidered
**** True optical drive vs hard drive
     The optical path can be a true optical drive or a hard drive directory.
     The software can tell the difference.  File handling is different
     depending on this.  Specifically, a disk cache is only used if a true
     optical drive is present.
***** Optical drive present
      When Catalog is set to Optical, the optical path catalog database is
      copied to disk cache and read.  When a study is continued, the study
      directory is copied to the cache and all reading and writing is to the
      cache.  When the study is closed, the catalog database and study
      directory in the cache is copied to the optical disk, and the cache is
      cleared on successful copying.
***** Hard drive directory used as optical drive
      In this case, NO disk cache is used.  The catalog and study files are
      written to directly to the hard drive.  When the study is opened and
      closed, nothing special happens.  This behavior can be overwritten by an
      Option flag.
* Database
** Background
   It has become obvious that, similar to the Prucka system, the data
   stored by EP Simulator needs to be stored in a database.  Right now
   everthing is a flat file, and things like sorting, filtering,
   editing, adding new, deleting items is implemented in code.  Yuck!  
** Database selection
*** Sqlite
    Excellent choice for standalone program; not so good for networked
    system.  Not a client/server system.
*** MySQL
    Useful to emulate the Cardiolink server, ? if multiple users ever
    will be needed though.  More complex installation, setup.
** Use either?
   Not sure that will work -- might not be able to upgrade from one to
   the other.
*** MySql could be option for the network database.
    For the System and Optical database Sqlite or binary storage.
** What is stored on the optical disk?
   The study data itself is not a database file.  The study data is
   streamed to the optical disk as a separate thread, until it fills
   up.  The study data is also stored on the System directory, until
   the study is completed.  It is left on the System directory until
   data is exported if network export is enabled, after which it
   disappears from the system directory.  Studies can be reviewed from
   the Network directory, studies can be continued only if optical
   disk in place.
** Database tables
   - catalog
   - lists
   - intervals
   - etc
** QMysql -- Up and Running!!!
   This is an clarification of the method to compile the mysql plugin
   for the Qt SDK found in the the Help documents.  Originally I was
   getting errors in compilation due to using command line 'qmake'
   which is not the qmake in the Qt SDK.  I needed to run qmake using
   the full path to it:

   /home/mannd/qtsdk-2009.05/qt/bin/qmake

   Note that the path to the mysql include files and the
   libmysqlclient file must be correct.  You must be in the correct
   directory:

   cd ~/qtsdk-2009.05/qt/src/plugins/sqldrivers/mysql

   Here is the full command line on SuperSluggo:

   ~/qtsdk-2009.05/qt/bin/qmake "INCLUDEPATH+=/usr/include/mysql" 
   "LIBS+=-L/usr/lib/mysql -lmysqlclient_r" mysql.pro

   After this do a make and make install (no sudo).  Look in the 
  /home/mannd/qtsdk-2009.05/qt/plugins/sqldrivers directory:

  total used in directory 3120 available 356853920
  drwxr-xr-x  2 mannd users    4096 2010-05-18 18:59 .
  drwxr-xr-x 11 mannd users    4096 2010-01-08 21:20 ..
  -rwxr-xr-x  1 mannd users  446207 2009-11-26 10:09 libqsqlite2.so
  -rwxr-xr-x  1 mannd users 2041224 2009-11-26 10:09 libqsqlite.so
  -rwxr-xr-x  1 mannd users   73896 2010-05-18 18:59 libqsqlmysql.so
  -rwxr-xr-x  1 mannd users  599206 2009-11-26 10:09 libqsqlpsql.so

  There is libqsqlmysl.so!
** Redesigning catalog
*** Bugs
    - changes to patient information in Recorder are not copied to
      Catalog
*** Catalog's current process
    - Catalog is a QMap of the study-key() and StudyData which is a
      complete copy of the Study, the location, disk side, labName and
      machineName. 
    - TableListView just shows Study type, last name, first name, full
      name, mrn, study date/time, study config name, study number,
      location of study, and optionally study key.
    - New Study uses getNewStudy() to get Study*. 
    - getNewStudy() uses getSelectedStudy() which returns 0 if no
      study selected, and returns Study* to tablelistview's study.
    - getSelectedStudy() simply returns tableListView_->study();
    - TableListView::study() 
      - returns 0 is no selected items
      - else returns a new Study which is a copy of the Study stored
        in the QMap of the Catalog* identified by the key stored in
        the TableLIstViewItem.
    - TableListView is constructed of TableListViewItems, A Study& is
      passed to TableListView::addStudy() to get the study data for
      the columns.
    - TableListView::load() clears the list, takes a Catalog* and
      iterates through it, adding the CatalogMap.study and the catalog->location(it.value()).
    - Catalog::location(const StudyData&) 
      - returns empty QString if StudyData.study.isPreregisterStudy()
        is true, 
      - otherwise returns StudyData.location and
        StudyLocation.side.
** Database reconsidered
*** EpLists
    These are simple StringLists.  They are rarely edited.  There are no
    problems with concurrancy.  They can be simple binary files.  One database
    option would be to use an sqlite database to initialize the data.
*** Updated Rationale for database use
**** Networked vs Standalone system
     This is a simulator, most users will use it as a standalone system.  All
     files will then be on one machine.  In a networked system, multiple users
     share the same database.  One would still not expect many users even in
     this type of system.
**** Switching types of systems
     If a system is switched from single user to multiple users, it is
     necessary to set up the database on the network server.  Default
     databases can be constructed automatically, or, more realistically, a
     single user database can be exported (either to merge or replace) to the
     server.  The reverse process would take a network database and move it to
     a single machine.  These functions are handled by the 
     import and export lists and report format functions.  If a database is
     not present at startup, a default one can be created.
**** Database storage vs binary formats
     Although binary formats are fast, it is necessary to serialize the data
     back and forth from and to the disk, and each data file is separate.  In
     addition, sorting, finding, etc. have to be done in code.  Using a
     backend database, data can be handled by SQL statements, models, and by
     Qt views that can deal directly with models.  In addition, there is
     better scalability: if Sqlite eventually doesn't cut it, it is relatively
     easy to use MySql, especially if we avoid low-level sql queries.  Thus
     the application could be recompiled with MySql support if needed.
*** Databases
**** Structure
***** Primary key
      All tables will have an autoincrement primary key.
***** Unique values
      It does not appear necessary to enforce unique values.  However having
      unique values might help in queries, making sure the right answer is
      delivered when there are duplicates.
***** Indices
      Sortable fields will be indexed.
**** Databases
***** epsimulator.db
      Will contain lists, protocols, study configurations, etc.  Note that
      window configurations are not kept on the network, they are always per
      machine, per the Prucka manual.  Also note that an individual study
      configuration is a separate file, with a copy kept in each study
      folder.  Thus the data contained in a study configuration in
      epsimulator.db will need to be copied in a non-database format to each
      study folder.
***** catalog.db
      These database files reside on each optical disk, each system and each
      network.  When waveform data is archived to the network, the system
      catalog is cleared out.  I believe that is a networked study is
      continued or reviewed, it goes back into the system catalog.  (not sure).
***** Non-database files
****** ? Report formats 
       These might be ok for databasing, but will defer thinking about them
       for now.
****** Window settings
       These can be streamed in binary format to local disk.  These are never shared.
****** Study data
       The catalog identifies the location of study data on disk.  There is a
       unique folder for each patient.  This folder name, based on the study
       key, doesn't vary, only the path does.  This study data is copied whole
       from disk to disk.  Examples follow:
******* Standalone system
******** New study
	 - study directory is created in .epsimulator/Studies
	 - when study complete, folder is copied or burned to Optical drive (which may
           or may not be an optical disk).  Optical drive catalog updated.
	 - Study data removed from system after being copied to drive
	 - System catalog maintains study info permanently (but not waveforms,
           etc.)
******** Review, continue study
	 - Insert optical disk
	 - Copy disk data to cache
	 - when done, clear cache again
******** Lists, etc
	 All kept in .epsimulator/ on local machine.
******* Networked system
******** New Study
	 - waveform data kept locally, other study data duplicate kept on server
	 - same copying to optical disk when done
	 - waveform data archived periodically to server.  System catalog is
           cleared out after archiving.
******** Review, continue study
	 Same as standalone system.
******** Lists, etc.
	 All kept in .epsimulator/ on server.
** Database naming style and structure
*** General
    There is a lot of debate between different styles, including singular vs
    plural table names, MixedCase vs underlined_words, prefixing table names
    to id, etc.  I have chosen MixedCase style or tables and fields, similar
    to class names and constants in the C++ code.
*** Table names
    Will use plural names, e.g. Intervals, not Interval.
*** Case
    MixedCase style.
*** Id
    In order to have automatic joins on primary and foreign keys, the names
    need to be the same.  So, for Id only, will preface table name (singular
    form).  E.g. Interval_ID.  Note that ID is capitalized for this use.
*** Primary key
    All tables will have a primary autonumber integer key.  This includes
    single column tables with supposedly unique values.  There seems to be no
    particular reason to restrict duplicate values, they can always be deleted.
* Singleton elimination
** fileutilies.h
   Need a polymorphic class that can save system data.  E.g.

template<typename T>
class SystemData {
public:
    SystemData(T* t, const QString& systemPath);
    
    virtual void save();
    virtual void load();
private:
    T* t_;
    QString systemPath_;
};

template<typename T>
class NetworkData : public SystemData {
public:
    NetworkData(T* t, const QString& systemPath,
    const QString& networkPath) : SystemData(t,systemPath) {}

    virtual void save();
    virtual void load();

private:
    QString networkPath_;
};

template<typename T>
SystemData::SystemData(T* t) : t_(t) {}

template<typename T>
void SystemData::save() {


}

Actually need a SystemData object that is initialized correctly (?
polymorphic) and is passed to classes that need to system save data.
*** class Data
** class ItemList
   problem here is initializing list.  There is a makeDefaults()
   function that does that, but should only do this if no list has
   been saved to disk.  We must not save and load in constructors, the
   constructor should construct a basic object, that can be populated
   either from makeDefaults() or from the saved data file, as a
   separate method.
** TODO ItemList is DEPRECATED!
** detangling administrationAllowed()
   user->administrationAllowed(Options*) depends on user and options.  Rather than
   pass user and options object pointers to everything that needs this
   info, should just pass bool administrationAllowed.  Alternatively,
   adminstrator and user version of the objects requiring this info
   could be created, but this is probably overkill.
** TODO Consider having Administrator as subclass of User.
   - Make isAdministrator() virtual bool function.
   - user->name() can also be virtual.
* Data handling
** Local vs System data
   A common scenario is loading configuration data.  All configuration data is
   stored in the top level folder of each study.  When there is new study, the
   configuration data is initially loaded from the system directory.  Thus the
   st
* What does Study know?
** Before refactoring
   - Name
   - unique key
   - unique file name generated from key
   - stuff listed in catalog columns
     - Study Type
       - Study
       - Pre-register
     - Name
     - MRN
     - Study Date/Time
     - Study Config name
     - Study Number
     - Location (disk label, or network location)
   - Patient stuff, not in catalog, invariant, in Patient Information Dialog
     - date of birth
     - sex
   - Patient stuff, not in catalog, possibly variant, in Patient Information Dialog
     - height, weight, bsa
   - Patient stuff, not in catalog, possibly variant, not in Prucka Patient
     Information Dialog
     - ef
     - ischemia
   - Links to other data
     - Study Configuration
     - Heart name
   - Path related
     - path() returns path to specific study directory
     - filePath() returns full path to study.dat file
     - configFilePath() returns full path of config.dat file
     - dirName() returns name of study dir ("/study_" + key())
     - fileName() returns "study.dat"
* Patient simulation
** Situations
*** New patient (not copied from previous data)
**** Patient Information blank
**** Physiology tab
***** Select/Edit initial patient physiology
***** Note Physiology tab can be adminitrator only function
      If this is the case, users cannot enter new patients.  Patients must be
      preregistered by the adminstrator, who must fill in the Physiology tab.
      Alternatively, new users who create a patient can get a default
      physiology.  Of course if users are allowed to adjust physiology they
      can do it themselves.
***** Drop-down list of named physiologies
***** Options to save or save as altered physiology
      Otherwise altered physiologies just apply to single patient.
***** Checkboxes, etc. to set physiology parameters
**** Drug tab
***** Initial drugs are set here
***** Other drugs are added during the procedure
***** This can include sedation
***** Can be represented as table of drugs, doses, routes
**** Heart tab
***** Similar to Physiology tab, ability to save, save as
***** Ability to alter cellular and macro physiology
*** Patient class
**** Basal characteristics
     Each patient has certain basal characteristics that exist at the start of
     a study.  Patient generation is much like character generation in a
     computer game.  You can start from scratch.  All physiology has default
     setting, heart is normal, etc.  You name the patient, adjust age, sex,
     basal autonomic tone, basal heart rate (calculated as intrinsic heart
     rate before effects of autonomic tone), add drugs, add diseases, etc.
     You can create a new study based on an old patient, make some changes to
     the physiology, or make marked changes and make it into a new patient.
**** Copying a Patient
     A patient is copied when starting a new study based on that patient.  It
     is only the basal characteristics that are copied.  E.g. patient at end
     of first study had last BP of 127/89.  Basal BP though is 120/60.  That
     value is copied.  
* File management
** Where are the files?
*** fileutilies
    - functions
      - in namespace EpCore
      - saveData() saves binary data to filePath with magicNumber
      - loadData() loads binary data from filePath with magicNumber
      - saveSystemData()
	- saves data to both network and system paths
	- depends on Options
	- deprecated?
      - loadSystemData()
	- loads data from network path if network storage enabled, otherwise
          system path
	- depends on Options
	- deprecated?
      - systemFileExists(Options*, QString fileName)
	- return true if fileName is in activeSystemPath(options)
      - deleteDir()
      - copyDir()
      - directoryOf()
      - rootDirectory()
	- directoryOf(".")
      - rootPath()
	- directoryOf(".").path()
      - systemDirectory()
	- directoryOf("System")
	- should be deprecated
      - activeSystemPath(Options*)
	- if network storage enabled then returns options->networkStudyPath
	  else options->systemCatalogPath
      - copyFilesToPath()
      - copyFilesToSystem()
	- copies files to epOptions->systemCatalogPath
	- also copies to epOptions->networkCatalogPath if Options::EnableNetworkStorage
	- has epOptions macro !!!!
      - joinPaths()
      - capitalize(const QString&)
      - isRemovableMedia(QDir)
      - useDiskCache(QString path)
	- uses epOptions macro !!!!
	- checks to see if path isRemovableMedia()
	- returns true depending on disk cache options in Options
      - osDependentSystemPath()
      - diskFreeSpace()
	- undefined
    - classes
      - SystemData
	- SystemData(const Options*)
	- save(const T& data)
	- load(T& data)
	- << and >>
      - SystemStream
	- SystemStream(const QString& systemPath)
      - NetworkStream
	- NetworkStream(const QString& networkPath, const QString& systemPath)
      - DataStream 
	- abstract base class to above 2 classes
	- static DataStream<T>* createDataStream(Options*)
	- save(const T& data)
	- load(T& data)
*** options
    - paths
      - opticalStudyPath
      - networkStudyPath
      - exportFilePath
      - tempStudyPath
      - systemCatalogPath
    - functions
      - includeNetworkCatalog()
      - EpCore::systemPath()
	- uses osDependentSystemPath()
	- attempts to create path if it doesn't exit
	- throws exception if can't do above
*** user
    - no file functions
    - administrationAllowed() depends on Options
*** main
    - createConnections()
      - EpCore::Constants::EPSIM_DB_FILENAME from coreconstants.h 
	- EPSIM_DB_FILENAME = "epsimulator.db"
      - EpCore::systemPath() from options.h
	- systemPath() = osDependentSystemPath()
	- osDependentSystemPath() = 
	  - Mac: systemDirectory()
	  - Linux: ~/.epsimulator/
	  - Windows: [APPDATA]\epsimulator\
	    - note: APPDATA on Vista is X:\Users\{username}\AppData\Roaming and on XP
              is X:\Documents and Settings\{username}\Application Data
      - Network catalog
	- options->includeNetworkCatalog()
	- options->networkStudyPath
      - Default database
	- EpCore::rootPath() + db/ + langSubDir + dbFileName
	- EpCore::rootPath() from fileutilities.h
	  - rootPath() = rootDirectory().path() [fileutilities.h]
	  - rootDirectory() = directoryOf(".") [fileutilities.h]
	  - directoryOf() is os dependent
	    - windows 1 dir up from debug/ or release/ otherwise active dir
	    - mac 3 dirs up from active dir
	    - linux 1 up from bin, otherwise active dir
	    - active dir is QCoreApplication::applicationDirPath()

*** abstractmainwindow
    - AbstractMainWindow(Options*, ...)
    - changeDatabase()
*** opticaldisk
    - various cache function, path functions, etc.
** Database files
*** System files
**** epsimulator.db
*** Study files
** Binary files
* Channels
** How does the simulation work - the basic loop
   - QTimer member of RealTimeWindow
   - A rectangular window is drawn at the head of the sweep using the
     background color
   - Each channel on display page is polled in order
   - An int is received from each channel
   - This int is the Y coordinate of the output of the channel
     - which is an amplitude in reference to each channels zero Y coordinate
   - The X coordinate is determined by sweep speed and screen size
   - A QPoint is generated and a line is drawn from the last QPoint to the
     current one
   - The process loops
   - When the X coordinate reaches its max value it goes back to 0
** Whiteboarding channels
   RealTimeWindow is polling each channel.  This is a QList<Channel>
   presumably.  So, 
* StudyManager class
** Rationale
   Managing the intricacies of using studies is highly complex.   
** Roles
   - Set up directory structure for a new study
   - Needs to know
     - Study directory name (study.dirName())
     - Optical disk path
       - is it a real optical disk or not?
     - cache path
     - network path
     - hold study data in System?
     - copy study data to Network?
   - Methods
     - Constructor
       ? pass all the specific options as a struct/class, as opposed to
       passing const Options& ?
     - class StudyPaths?
       data class only?
#+BEGIN_SRC c++
class StudyPaths {
    QString opticalDrivePath;
    QString cachePath;
    QString systemPath;
    QString networkPath;
};
#+END_SRC
** Revision of above
   - Needs to know
     - OpticalDisk* pointer to current disk, must be valid
     - 
* Catalogs reconsidered
** Database connections
   All database connections are opened and global.
** Role of StudyTable
   StudyTable sets up all 2 or 3 catalogs and switches back and forth among
   them.  Study table can get the Study info from the table to continue or
   review a study.  When adding a new study, StudyTable adds to optical disk,
   System, and, if set up, Network catalogs.
** Lifecycle of a Study
*** New Study
**** New Study button clicked, no old study selected
     - Study* s = new Study;
     - QString key = s->key();	// QUuid::createUuid().toString();
     - QString studyDirName = key;
** Review of CardioLink Operator's Manual
*** Types of Data
    - database data
    - waveform data
    - simulator data
*** Files
    - catalog.db 
    - study.dat
    - patient.dat
    - config.dat
    - waveform.dat
*** catalog.db
    Question is: put all of study data into catalog.db?  Then it would be
    possible to extract a complete Study object from catalog.db.  Then no need
    for study.dat.  If so, catalog.db is kept in all 3 places potentially.  If
    so, patient.dat is only kept in study directory either on optical drive or
    network, after waveform data moved.  
*** Notes from the Cardiolink Manual
    - 
*** Possible solution
    Create study directory in all open catalogs (i.e. System and Optical
    plus/minus the Network catalog.
**** Consequences
     - studies directory in each location
     - study.dat file used for binary study data
     - catalog.db limited to what appears in StudyTable - faster, cleaner
     - binary data copied from OpticalDisk to System at study close
     - if Network catalog used, copy waveform data too, then batch copy to
       Network server in background
*** Option for No Optical Disk?????
    All data saved to System, possible also to Network?
