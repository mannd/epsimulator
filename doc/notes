Developer notes

Problem with ui.h file.  Adding code to Form::Init() did nothing.  I had to add
a new slot to the form called init(), and this was added to the end of the
constructor of the Form in the generated Form.cpp file.  I still needed to have
the Form::Init() function in the ui.h file.

Ok, in KDevelop, add a public slot called init().  When asked for
implementation class for the dialog, hit cancel.  This will create the
Form.ui.h file.  Everything seems to work ok now.

Source code formatting

Will stick to Bruce Eckel convention of starting brace always at end of line.
indent with spaces 4 spaces.
Header files go from most specific to general as in Eckel.
Will use the get and set convention for member functions.
     Note it is possible to avoid get, for example:

Class Fruit {
      public:
            Fruit(string banana);
	    void setBanana(string banana);
	    string banana();
      private:
	    string banana_;
}

Actually I have now changed to the above style.

private variables will end in underscore.
//enums, consts and defines will be all caps.
enums, consts and typedefs will be UpperCamelCase
defines will be all caps with underscores


Unit Testing
For now will use cxxtest.  Run ./maketests from epsimulator/src to generate the
runner program.  Edit maketests to add dependencies, and MyTestSuite.h contains
the tests.  The tests HAVE to be in the src directory to compile, and so tests
are not a subproject.  Need to make the test suite into a make file, using a
different makefile name than Makefile, e.g. maketests and invoke as make
-fmaketests, e.g.  Could make a link to this named maketests to keep everything
the same.

Unique identifier for each study
A key for each study can be constructed by
lastName+"_"+firstName+"_"+date/time.  Use this for the file name of the data
files and use this to locate the study data in the studieslist (? Make this a
map between the key and the data?)

Use QString QDateTime::toString(const QString& format) const to generate the
date time of the study.  This format string should work:


dd.MM.yyyy.hh.mm.ss // This has been changed to ddMMyyyyhhmmss, without the dots
in between.

? add millisecs: zzz

Thus the map could be: QString key: Study study.

I need to be able to generate the key from the QListView (note QListView has
full name and formatted date time as strings, so not easy to change format
back).

Can use QListView::hideColumn(int column) along with setResizeEnabled(FALSE,
column) to have hidden list view columns.  The hidden column can contain the
map key.

FIX FOR CXXTEST PROBLEM

Merely including ALL the *.o files needed all Qt-specific tests to compile. 
That is, to test PatientDialog, must include in linked files patientdialog.o,
moc_patientdialog.o, patientdialogbase.o and moc_patientdialog.o.  (Actually
maybe the non-moc ones are needed -- will test: no all the above mentioned files
are needed.)

MORE FORMATTING WOES
    Objects in .ui files are actually public data members; therefore should not
end in _.  Menu items, etc. are private and should end in _.

How the Catalog Works
    There is only one catalog.  This resides in the program subdirectory system:
 i.e.  epsimulator/system.  This catalog contains all study info.  Studies can
be in the following places:
        Local       This is by default the epsimulator/studies directory, but
can be changed in the systemdialog.
        Optical     This is by default whereever the optical drive is.  We need
some sophisticated programming to get this right on program installation.
                        Will set it to /dev/cdrom for now.  Obviously not right
for Windows.
        Other       This will by default equal the Local directory, but can be
changed to another directory with a file dialog.
        Network     This is a network directory.  This will be by default be
blank.  Any blank directory will get an error message that the directory needs
to be setup.

    When the catalogComboBox is set to System, all known studies will be
displayed.  When set to any of the others, only the studies in that particular
directory will be displayed.  When Other is selected, a file dialog will always
come up, set to the last Other location, to allow changing on the fly.  Again,
an empty path will display and error message, except with Other, when a file
dialog will come up.  Other than Other, the paths need to be set with the
systemdialog, and this can be an administrator function, password protected. 
Also consider disabling the Other option via the systemdialog.  

    The StatusBar will display the current source: epsimulator/system for
System, local path for others, consider (Optical) for Optical.    Refresh
rereads the studies.eps file.  Regenerate needs to go through each path, make
sure each study in each path has a catalog entry, and generate one if not.  The
TableList is filtered based on the catalogComboBox.  Any filter on top of that
is done separately.  Refresh can be done on a filtered list (by rereading the
catalog and reapplying the filter).  Regenerate needs an unfiltered list.  Note
that Regenerate when applied to anything other than System will just look at
that pwhere to put data files qt applicationarticular path (E.g. the Local
path).

Some problems:
    There is no easy way to find the application directory in Linux.  Data files
should go to standard Linux File System locations.  These might depend on where
the application is installed (to /usr/local/bin or to ~/bin???).  If the system
and data directories don't exist they must be created initially.  This is not
hard to do, but does need to be done.  Qt doesn't use the ./configure
--path=whatever so no easy way to determine where the app was installed. 
Hmmm.........
    For now we will be lazy and put the studies.eps catalog in the home
directory, and the actual studies in ~/MyStudies.

More on Catalog
    Studies should either be in the MyStudies directory, or can be moved to
other directories.  studies.eps keeps track of all study locations.  Studies
generated from another system really should be imported into the studies.eps
catalog.  E.g. You have a study someone else made on a CD.  You want to review
it.  Import it in: it's location appears as the path of the CD-rom.  You can now
review the study.  If the CD is removed and the file can't be found, the program
prompts for inserting the correct CD.  So there should be a System and a Local
selection in catalogComboBox.  System shows all, and Local shows only studies on
MyStudies (which should be most of them anyway).  

    Need to check into data streaming for R/W CD-roms.  Should I have an optical
drive in the system, which could be set to a hard drive path if desired?  Then
each disk would have a label, stored in a file on the disk, which would appear
in the location column of catalog: e.g. D:/(Optical)/Disk23.  In Linux would be
/media/cdrom0/Disk23.  Each disk would have a study catalog, and System and the
disk catalog would be updated simultaneously.  Refreshing should just reread the
catalog, regenerating only applies to single disks and rebuilds the catalog(s)
from the studies on disk.  The network has its own catalog and studies are
exported to the network.  The System catalog keeps track of what it has exported
to the network, but the network catalog contains all the networked items.  This
is a major reworking, but similar to the functionality of the Prucka system.

How Prucka does it.
    Prucka maintains a "maximum of 3 catalogs."  These are, in order Network,
    System, and Optical.  In addition the Switch menu adds an Archive Server
    item (presumably allowing retrieval of archived studies) and a
    Browse... item, allowing the opening of any catalog file.  The catalog
    files are all called study.dat, and there is one on each optical disk, one
    in the System submenu of the Prucka directory, and one on the network.
    When a study is added, ALL 3 of the catalog files are updated.  The
    Location column in the catalog actually just contains disk labels.
    Presumably the reason for the 3 catalogs is to have a way to identify
    studies on each particular disk (that is the only catalog that can be
    regenerated), to track studies on a specific machine, and to have a
    central catalog on network in labs with multiple machines.  This
    architecture is worth preserving, particularly if the program is used in a
    teaching environment.  The problem is with the optical disks.  I'm not
    sure this will work with CDROMS.  Would like to use hard drive directories
    to emulate optical disks.  The Optical "drive" would be a path,
    e.g. ~/optical.  Each disk would be a subdirectory of the optical
    directory.  E.g. disk 23A would be ~/optical/Disk23A.  Labeling and
    Relabeling the disk would be renaming the directory.  Each "disk" would
    have a studies.eps catalog file.  The network catalog is optional and can
    be a mounted directory on Linux.  Would like to have an option (set true
    and not enabled for now) for "optical drive emulation."  Need a separate
    Simulator menu item for this sort of thing.

    The Export menu item exports a *.txt file of the catalog.

    Also, see the EPMed system for a software stimulator.  

More on Catalog/TableListView/OpticalDiskDrive/OpticalDisk...
    This is totally confused now.  When a catalog is selected, it is read from
the disk.  In the case of the System and Network catalogs, these are in fixed
locations.  When the Optical catalog is read, there must be a disk in the drive,
etc.  If a new patient is selected, the Location of the study depends on if a
disk is in the drive, and the disk label.  So there must be a process to insert
a new disk or identify the current disk, if not present on initiation of
Navigator, present when any of the above happens.  It might be better to defer
the drive stuff until it is needed, not when the central widget is set up.  So
everytime optical is selected, this has to be confirmed.  
    
    So, Navigator starts up.  nothing is done with optical disk.  Switch to
optical catalog.  Check if diskdrive is setup.  If not error message, set up
disk drive, or create directory that needs to be created.  Check if disk in
drive.  If not, "insert" disk, create label.  This is current disk, and includes
the directory, etc.  Same thing if a button (like new patient) is pushed.  If
catalog saved, save to disk if it is there, otherwise forget about it.  Now what
are the routines, and where are they?

    OpticalDiskDrive
        bool checkDrive()
        bool setupDrive()
        bool ejectDisk()    // ? in OpticalDisk

    OpticalDisk
        void labelDisk(QString)
        void setDiskSide(bool sideA)

Note on disk labels and sides:
     With optical disk emulation, the "disk drive" is the .../MyStudies
directory.  The "disk" in the drive is a directory with format "Disk11B", i.e.
"Disk" + label + side.  So the path to the catalog file for disk 11, side B
would be .../MyStudies/Disk11B/catalog.eps.  The study data for each study is in
a unique directory labeled by the generated key() for the study.  The structure
below that is unknown at present.  OpticalDiskDrive is responsible for making
sure a disk is in the drive, it is readable, etc.  OpticalDiskDrive stores the
real path to the real or emulated drive.  OpticalDrive has it's own path, which
is null for a real optical drive, and is generated from the label and side as
above.  

Simplified version of above.
    OpticalDiskDrive is unnecessary.  All you need is the path to the drive. 
The simplist emulated optical disk is just using a directory such as MyStudies
as the path to the optical drive.  This "drive" will fill up until limited by
the hard drive space.  But it works exactly like a path to a real optical disk
otherwise.  But the OpticalDisk class can keep the path private, based on the
system setting for optical drive path.  The class can then have a writeLabel()
and readLabel() virtual function, a writeCatalog(), addStudy(), readCatalog()
function, etc.  EmulatedOpticalDrive has the same functions, but internally
keeps track of subdirectories for each drive.  
        

Note on vtable errors: after adding classes, or editing the src.pro file, you
must rerun qmake, or your class doesn't get run through moc, or the moc_version
of your class is not linked.  This causes those unable to find vtable errors by
linker.


Certain options are Simulator options.  There is a special Menu Item,
"Simulator" where all the simulator options are set.  These include options to
make the interface closer to the actual Prucka system.  For example, The
navigator table can have columns for last name and first name, like the Prucka
does, as clunky as this is.  Emulate optical drive is also a simulator
specific item. 

The Simulator options dialog is a large tabbed dialog, with tabs for different
sections of the simulator.  Perhaps we can subclass menuitem and allow
different color menu item for the simulator menu item.

Formatting for Doxygen

We will prefer the @file, @param format to \file, \param.

Note about Navigator problem.  Navigator tablelistview disappeared along with
horizontal splitter and part of tool bar.  It was due to corruption of the
epsimulatorrc file, a bad pointer was loaded from the file.

BUG: if no network path in settings file, catalog still tries to load the
network catalog, even if system options show there is no network storage, and
this throws and exception.  Need to check out what is happening with catalogs
when there is no network catalog.

Regenerating:
	We will read the current disk label, and, if this is an optical disk, we
will read
	each study file and write the study data to the new, blank catalog.dat
file and 
	then write the label as the study location.  Then regenerate the other
catalogs,
	which will write the correct info plus the label.  When relabeling a
disk 
	(not a new disk, an old one), regenerate to make the above happen.  Note
that
	the key() for each study never changes!!!!!, this is the only way to
have
	identify studies when everthing else changes.
	
Study files
	An "optical disk" is set up like this:
	
	With plain optical disk, /(diskpath) is path to the disk.
	This can be something like /media/cdrom or /home/MyHome/MyStudies.
	
	With emulated optical disk, /(diskpath) is the above plus the
	directory /disks/ plus the name for each disk.  This diskName is NOT
	the same thing as the study label.  The diskName is generated when the
	disk is first used.  It is disk_XXXXXXXX, where the XXs are the
	date/time when it is created.  Within this diskName directory is the
	label.dat, catalog.dat and data files.  To account for 2 sided disks,
	There are 1 or 2 directories within the disk_XXXXXXXX directory:
	A/ or B/.  One-sided disks just use A/ and don't need a B/.  Having A/
	present in all disks allows the user to change his mind and switch
	from a one to two-sided emulated optical disk without losing data on
	the first side.  If B/ is not present, it can be created at that
	time.  If a user changes from 2 to 1 sided disks, he will be warned
	that he will lose the 2nd side information (this is only fair).
	Certainly users should not be changing disk emulation willy-nilly.
	Thus, example diskpaths:

	~/MyStudies/
	/media/cdrom/
	~/MyStudies/disks/disk_XXXXXXX/A/
	~/MyStudies/disks/disk_XXXXXXX/B/
	
	
	The data directory holds a directory for each study.  This directory
	is /study_XXXXXXXX, where the X's are the key for the study.  Within
	this directory is a file named study.dat, which contains the study
	data used by catalog, and all the data files generated by the study
	itself.  The nature and content of these files/directories remains to
	be determined.

	Thus:

	/(diskpath)/
	/(diskpath)/catalog.dat
	/(diskpath)/label.dat
	/(diskpath)/data/
	/(diskpath)/data/study_XXXXXXX/study.dat 

	Using an emulated two-sided disk:

	~/MyStudies/disks/disk_XXXXXXX/B/catalog.dat
	~/MyStudies/disks/disk_XXXXXXX/A/data/study_XXXXXXXXXX/study.dat


TODO: extract common menu actions and make a concrete base class to hold them. 
Derive the navigator, stimulator, recorder actions from this class.  e.g.
    class Actions {};
    class NavigatorActions : public Actions {};
    class EpSimulatorActions : public Actions ();
    etc.
Actually it is better just to put the common actions in a struct, with public
    QAction data members.


On labels, sides, locations.
   We have removed location, side, epLab and machineName from Study and placed
   in the catalogs, using struct StudyData.  TableListView lists the location
   in a format that depends on the catalog.  The optical catalog does not list
   pre-registered studies.  A warning might need to be issued when one is in
   the optical catalog when entering a pre-register study, or the catalog
   could automatically (and maybe disconcertingly ) change to System or
   Network if this is the case, OR, we could leave the preregister studies in
   the optical catalog, although there will be no actual study on the disk.
   Need to decide, perhaps see what Prucka does.

   A non-emulated optical disk is just a directory.  If it is removable media,
   the catalog.dat file will disappear or change when the disk is changed, and
   if it disappears, the program will prompt for a new label for the new
   disk.  If you just store all your studies in a hard drive directory
   (MyStudies), then even if you click on eject disk, the catalog will always
   be there unchanged, and all the studies will stay in the same directory.
   Of course you can change the default studies directory, and a new catalog
   will be written, etc.

   When you label a new disk (non-emulated) you can arbitrarilly add a side (A
   or B) to the label (stored though separately as StudyData.side).  For
   removable dual sided media, this makes sense, and it is up to the user to
   select the appropriate side.  For a hard disk directory, the side doesn't
   make much sense, but you could add it to your label if you want.
   Relabeling a removable or a fixed disk would allow you to change or
   eliminate the side part of the label.  The only thing that changes is the
   label info stored in the catalogs, nothing in study.dat or the directory
   tree changes.

   Given this, it makes sense to have 3 options for side in the disk label
   dialog: None, A, or B.  

   Emulated Disks are trickier.  The Side is part of the directory tree, so
   once it is picked out, it cannot change.  The label though is not part of
   the tree, so relabeling is ok.  So,

   New emulated disk: If emulate dual sided disks is checked, then the 2
   sides, A or B, are options, but None can't be an option.  A or B will
   determine whether the study data goes into the A or B subdirectories.

   If dual sided disks is unchecked, then only None is an option, or the sides
   button group is disabled.  However, then all study data goes into the A
   subdirectory and there is no B subdirectory.

   Relabeling emulated disks:  You can change the label, but not the side!
   The side button group is greyed out, whether emulate dual sided disks is
   checked or not.  

   Other circumstances:

   Emulated disks, change from emulated dual sided disks to not emulate dual
   sided disks: This should probably be disallowed, as B side studies will
   become inaccessible.  Ordinarily if there is no dual sided disk emulation
   the disk side will not show up in the catalog, so A and B sides would all
   appear to be one location.  Note that this is not true for non-emulated
   disks, as the side option will always be available (including no side).
   One solution would be to not show the disk sides in the above scenario, but
   still have the side information stored so the proper disk side (and
   subdirectory) will be used.  A warning message can be issued.  Returning to
   emulated dual sides would restore the status quo.

   Emulated disks: change from not emulated dual sides to emulate dual sides:
   This should be ok.  All studies previously stored will appear on side A,
   later studies added will be on A or B.

Further elaboration:
    The label.dat file must contain both the actual disk label AND the side.
    Side can be null for non dual side drives.  Otherwise 2 sides of the same
    drive will have the same label.

Regenerating Catalogs
    The Regenerate method rebuilds the set of Catalogs, from the study.dat
files.  It must start with the current optical disk.  The path to the studies
folders is, for example, .../MyStudies/studies/.  There are a number of studies
folders (0 or more), all beginning with study*.  Thus
.../MyStudies/studies/studyxxxx, .../MyStudies/studies/studyyyyy, etc.  Inside
each folder is a study.dat file.  Read each one into the optical disk catalog
and replace the current optical disk catalog, catalog.dat.  Then get the study
keys from that catalog.  Read each of the other catalogs, and if there is a
match, replace the data in the catalog.  If no match, add the data to the
catalog.  Save all the catalogs.

Style Note:
    struct data members will have no ending underscore.  Underscores indicate private data members.

More on Sides:
    isTwoSided function doesn't apply to the "regular" optical disks.  Changing the side with relabel, from none to A to B will always be reflected in the catalog listing.

    Emulated optical disks are one sided or 2 sided.  A one sided disk has a side of none (QString::null).  A 2 sided disk has a side of A or B.  This will automatically be shown correctly in the catalog by the same mechanism as above.  The difference is, a one-sided disk still has its data in the A subdirectory, just like a 2 sided disk using side A.  AND, emulated optical disks cannot be relabeled to a different side!  That would mess up the location of the study files.  When a new emulated optical disk is labelled, if options are set to one sided disks, the side choice is none and disabled on the disk label dialog.  If set to 2 sided disks, the none option is disabled from the dialog.


Copy/Moving study data:
	    All directories holding study data are treated as optical disks.
	    There must be a label and a catalog file in each such directory.
	    The tracking catalogs (System and Network) hold the one official
	    location of the study data.  If copy is used, this doesn't change,
	    if move is used, the new location is used as the official one in
	    the tracking catalogs.  There are no other tracking catalogs than
	    those two.  
	    
	    So, to move/copy a study, you must go to a directory that is
	    already set up as a disk, or set up the new directory as a disk.
	    What if you are using emulated disks?  Shouldn't you be able to
	    copy from one emulated disk to another?  But can you also copy to
	    a non-emulated disk directory?  This should be possible.  If you
	    are not using emulated disks, you do not have the option to copy
	    to an emulated disk, other than accessing the emulated disk
	    directory directly.

	    So, copy first (easier, no updating of catalogs):

	    No disk emulation:
	       Pick out a directory.  If not initialized do so, i.e. label it,
	       set up catalog.  Copy study folder.  Update local catalog.
	       Move: do above, then update tracking catalogs.

	    Disk emulation:
		 Use select disk dialog to select disk.  Do above to selected disk.

Source Code Reorganization

    I need to use libraries in order to link properly, now that modules are in their own directories.  Modules shared between navigator and recorder should be in a shared library.  During installation these libraries can be installed in the usual library locations in linux.  During development, I have added a relative path to the LD_LIBRARY_PATH environment variable in the kdevelop project file.  The new variable is ./../../lib:$LD_LIBRARY_PATH.  This is a relative path, so it should work regardless of the absolute path to the sandbox.  Modules that are not shared (such as stimulator) can be static libraries, which are linked at compile time.  They still should end up in the lib directory.

    All image files (icons, etc) will be in the src/images directory.  There is enough overlap that it doesn't make sense to have individual subdirectories in each module for images.  ui files though may need to be in 2 possible locations.  The ones that are not shared can be in each module directory.  The shared ones should be in a src/ui or src/commondialogs directory.  I think that Patient Information is the only shared dialog that I know of.

    The test modules: should they be in test or src/test?  They should not be in the individual module directories because they can't be compiled as a subproject then.  Should there be more than one test program (navigator vs recorder?).  Probably not.

Namespaces

    Source code modules (or subprojects) have been reorganized.  Basic functions and classes used by all parts of the program are in src/core, and basic gui classes and functions are in src/gui.  Analagous to the QtCore and QtGui namespaces in Qt4, the corresponding namespaces are EpCore and EpGui.  I am also thinking of using a Ep namespace for very basic stuff, like the error handling functions.  *.ui files are now in ui subdirectories beneath the source code directories.  Common ui files are in the gui/ui directory.  Files specific to a module, e.g. the Navigator module are in a ui subdir of that module, e.g. navigator/ui.  To allow unit testing, all modules except main will be shared libaries.  This includes navigator.

Note that TableListView will stay a Q3ListView derived class, as the closest class in Qt4, QTableWidget is very different and finding equivalent functions between the 2 classes is very hard (I tried).  Thus Navigator will require Q3Support to compile.

Copying/Moving Studies
    Studies can be on an optical disk or in a directory of the hard drive.  The location of a study is either from the label of an optical disk of a hard drive directory.  We'll consider copying and moving equivalent, the only difference being that the 2 non-optical disk catalogs (System and Network) are updated with the new location of the study files.  Whereever a study is copied or moved, a catalog is created or updated in that directory.  The local catalog always reflects the location of the local copy, whereas the System and Network catalogs show the "official" location of the study.  

    Several possible types of copying are possible.  Assume first traditional (not emulated) optical disks.  One can copy from one optical disk to another.  In this case source and destination are the same (the text in the sourcePathLineEdit will be, assuming a path to the optical drive of /dev/hdc, /dev/hdc/(Optical)).  In this circumstance, the studies will be copying to the temp folder, and the "insert new disk" dialog will appear.  After clicking OK, there will be a check to make sure the labels are different, or the new disk is unlabeled.  If the latter, a new label will be generated (it can't equal the source label), and then the studies will be copying from the Temp folder to the new disk.  The new disk catalog will have the original location, though obviously there is a copy of the new disk too.  With moving, all the catalogs will be changed to the new disk location.  If the source and destination labels are the same (didn't really change the disk, or pretending the hard drive is an optical disk), an error will be thrown and the whole process cancelled.  If copying to a hard disk directory, a catalog will be created there, but no label.dat file; label.dat is only on optical disks.  

    With emulated optical disks, all the above must hold true, but with the usual emulated disk stuff behind the scenes.  To construct the study list, the dialog must know both the path() and the fullPath() (these are equal for optical disks, not equal for emulated disks).  So, pass both values?  Or just have the dialog read the current disk path -- it needs to know if it is an emulated disk or not???  Probably need to pass the opticalDisk* to the dialog, and should allow disk ejection in the dialog box, so that emulated disks work too.

Re Terminology
    To attain uniform terminology, use the file terminology used in Qt classes.  Here's an example:
        file = /home/user/MyStudies/studies/study1/study.dat
        directory = /home/user/MyStudies

    path() for a file is the path of the file, excluding the file name. 
        file.path() == /home/user/MyStudies/studies/study1
    path() for a directory is the whole path, including the directory.
        directory.path() == /home/user/MyStudies
    fileName() for the file is the file name without the path.
        file.fileName() == study.dat
    dirName() for the name of the directory without the path.
        directory.dirName() == MyStudies
    filePath() for the name of the file including the path.
        file.filePath() == /home/user/MyStudies/studies/study1/study.dat
    

    
